#!/usr/bin/env python3

"""
READ BEFORE USING THIS SCRIPT

This script is used to ease the process of managing Odoo containers.
However, it is not flexible enough to handle all possible cases.
If you want to use this script, you should read the following before doing so,
(or else you may did these with something's broken):

 1. This script can't (yet) handle volumes in docker-compose, Use bind mounts in your 
    docker-compose.yml.
 2. This script can't (yet) handle custom networks in docker-compose, this will break 
    updating and initializing modules, Odoo needs to be in the default "(dirname)_default"
    network.
 3. If you're on Docker on Desktop (with WSL2 backend or OS X), refer to the Odoo docker repository
    for configuring bind mounts and environment variables. Not doing this will break some 
    file permissions.
 4. `fscat` is broken on Windows.
 5. Custom container names are not supported.
 6. This script requires Compose V2.
"""

import os
import subprocess
from platform import uname
from sys import stdout, stderr, stdin, argv
from configparser import ConfigParser, NoSectionError, NoOptionError
from json import loads as json_loads
from yaml import safe_load, YAMLError


UPDATE_VARIABLES = ('OPTIONS__ADDONS_PATH', 'OPTIONS__DB_USER', 'OPTIONS__DB_PASSWORD', 
    'OPTIONS__DB_HOST', 'OPTIONS__DB_PORT', 'OPTIONS__DB_NAME', 'NO_CHOWN', 'OUID', 'OGID',
    'PIP_INSTALL', 'PIP_INSTALL_FILE')
PSQL_IMAGE = "lemniskett/psql"
SYSTEM = uname().system


class InvalidArguments(Exception):
    pass


class OdooDoesNotExist(Exception):
    pass


class DockerError(Exception):
    pass


def parse_args():
    # Using argsparser is too complicated for positional arguments, so we'll have this instead.
    """
    Parses the arguments passed to the script.
    """
    args = []
    flags = {}

    for arg in argv:
        if arg.startswith("--"):
            if '=' not in arg:
                flags[arg[2:]] = True
                continue
            key, value = arg[2:].split("=")
            flags[key] = value
        else:
            args.append(arg)

    return args, flags


def parse_config(conf_path):
    """
    Parses the config file.
    """
    if not os.path.isfile(conf_path):
        populate_conf(conf_path)

    conf = ConfigParser()
    conf.read(conf_path)
    return conf


def parse_args_after_delimiter():
    """
    Parses the arguments after the delimiter string "--"
    """
    args = []
    passed_delimiter = False
    for arg in argv:
        if passed_delimiter:
            args.append(arg)
        if arg == "--":
            passed_delimiter = True
    return args


def populate_conf(conf_path):
    """
    Populates the config file with default values.
    """

    with open(conf_path, "w") as f:
        f.write("""[default]
directory = /data
prefix = odoo
""")


def write_err(string):
    """
    Writes a string to stderr.
    """
    print(string, file=stderr)


def check_odoo_exist(version, flags, conf):
    """
    Checks if an Odoo container exists in a Docker stack.
    """
    profile = flags.get("profile", "default")
    directory = conf.get(profile, "directory")

    prefix = conf.get(profile, "prefix")
    with open(os.path.expanduser(f"{directory}/docker-compose.yml")) as f:
        dc_dict = safe_load(f)
        if f"{prefix}{version}" in dc_dict["services"]:
            return True
    raise OdooDoesNotExist()


def docker(args, **kwargs):
    """
    Calls the docker command.
    """
    array_args = []
    for i in range(len(args)):
        array_args.append(f'"{args[i]}"')

    if kwargs.get("capture", False):
        res = subprocess.run(f"docker {' '.join(array_args)}", stdout=subprocess.PIPE, shell=True)
        # Maybe log the stderr here.
        if res.returncode != 0:
            raise DockerError(res.returncode)
        return res.stdout.decode("utf-8")
    exit_code = os.system(f"docker {' '.join(array_args)}")
    if exit_code != 0:
        raise DockerError(exit_code)


def docker_compose(args, **kwargs):
    """
    Calls the docker-compose command.
    """
    array_args = []
    for i in range(len(args)):
        array_args.append(f'"{args[i]}"')

    if kwargs.get("capture", False):
        res = subprocess.run(f"docker compose {' '.join(array_args)}", stdout=subprocess.PIPE, shell=True)
        # Maybe log the stderr here.
        if res.returncode != 0:
            raise DockerError(res.returncode)
        return res.stdout.decode("utf-8")
    exit_code = os.system(f"docker compose {' '.join(array_args)}")
    if exit_code != 0:
        raise DockerError(exit_code)


def gen_container_name(args, flags, conf):
    profile = flags.get("profile", "default")
    directory = os.path.basename(conf.get(profile, "directory"))
    prefix = conf.get(profile, "prefix")
    version = args[2]
    return f"{directory}-{prefix}{version}-1"
        

def create(args, flags, conf):
    """
    Creates (or recreate) a new Odoo container.
    """
    if len(args) != 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    profile = flags.get("profile", "default")
    version = args[2]
    prefix = conf.get(profile, "prefix")
    docker_compose(["up", "--detach", "--remove-orphans", "--build", f"{prefix}{version}"])


def start(args, flags, conf):
    """
    Starts an Odoo container.
    """
    if len(args) != 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    profile = flags.get("profile", "default")
    version = args[2]
    prefix = conf.get(profile, "prefix")
    docker_compose(["start", f"{prefix}{version}"])


def stop(args, flags, conf):
    """
    Stops an Odoo container.
    """
    if len(args) != 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    profile = flags.get("profile", "default")
    version = args[2]
    prefix = conf.get(profile, "prefix")
    docker_compose(["stop", f"{prefix}{version}"])


def restart(args, flags, conf):
    """
    Restarts an Odoo container.
    """
    if len(args) != 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    profile = flags.get("profile", "default")
    version = args[2]
    prefix = conf.get(profile, "prefix")
    docker_compose(["restart", f"{prefix}{version}"])


def shell(args, flags, conf):
    """
    Starts an interactive shell in the specified container.
    """
    if len(args) != 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    profile = flags.get("profile", "default")
    version = args[2]
    prefix = conf.get(profile, "prefix")
    docker_compose(["exec", "--user", "odoo:odoo", f"{prefix}{version}", "bash"])


def attach(args, flags, conf):
    """
    Attaches to an Odoo process in the specified container.
    """
    if len(args) != 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    profile = flags.get("profile", "default")
    version = args[2]
    prefix = conf.get(profile, "prefix")

    if not flags.get("no-prompt", False):
        container_name = gen_container_name(args, flags, conf)
        res = json_loads(docker(["inspect", container_name], capture=True))[0]
        for var in res["Config"]["Env"]:
            if var.startswith("OPTIONS__LOGFILE"):
                key, value = var.split("=")
                if value != "":
                    write_err("WARNING: Logfile is set to {}. You'll not see any output from odoo.".format(value))
        print("This is an interactive screen session.\nUse Ctrl-A + D to detach from the container.")
        input("Press enter to continue...")
    docker_compose(["exec", "--user", "odoo:odoo", f"{prefix}{version}", "screen", "-xS", "odoo"])
        

def top(args, flags, conf):
    """
    Displays the top processes running in the container.
    """
    if len(args) != 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    profile = flags.get("profile", "default")
    version = args[2]
    prefix = conf.get(profile, "prefix")
    docker_compose(["top", f"{prefix}{version}"])


def ps(args, flags, conf):
    """
    Lists the running containers in a stack.
    """
    if len(args) != 2:
        raise InvalidArguments()
    profile = flags.get("profile", "default")
    prefix = conf.get(profile, "prefix")
    docker_compose(["ps", "--all"])


def update(args, flags, conf):
    """
    Pulls the latest Odoo image.
    """
    if len(args) != 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    profile = flags.get("profile", "default")
    version = args[2]
    prefix = conf.get(profile, "prefix")
    docker_compose(["build", "--pull", f"{prefix}{version}"])
    docker_compose(["pull", f"{prefix}{version}"])
    print(f"Run {args[0]} create {args[2]} to update the container.")


def update_module(args, flags, conf):
    """
    Updates the specified modules in the specified database.
    """
    if len(args) != 5:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    profile = flags.get("profile", "default")
    prefix = conf.get(profile, "prefix")
    container_name = gen_container_name(args, flags, conf)
    res = json_loads(docker(["inspect", container_name], capture=True))[0]
    image = res['Config']['Image']
    binds = res['HostConfig']['Binds']
    test_enabled = flags.get("test", False)
    bind_command = []
    for bind in binds:
        bind_command.append(f"--volume={bind}")
    for var in res['Config']['Env']:
        key, value = var.split("=", 1)
        if key in UPDATE_VARIABLES:
            os.environ[key] = value
    test_enable_flag = "--test-enable" if test_enabled else ""
    command = ["run", "--rm", "--interactive", "--tty",
        "--env", "OPTIONS__ADDONS_PATH",
        "--env", "OPTIONS__DB_USER",
        "--env", "OPTIONS__DB_PASSWORD",
        "--env", "OPTIONS__DB_HOST",
        "--env", "OPTIONS__DB_PORT",
        "--env", "OPTIONS__DB_NAME",
        "--env", "OPTIONS__LOGFILE=",
        "--env", "NO_CHOWN",
        "--env", "OUID",
        "--env", "OGID",
        "--env", "PIP_INSTALL",
        "--env", "PIP_INSTALL_FILE",
        "--env", "ONESHOT=True",
        "--env", "PURGE_CACHE=True",
        "--env", "ODOO_STAGE=update",
        "--env", f"OARGS=--database={args[3]} --update={args[4]} --stop-after-init {test_enable_flag} --config /opt/odoo/etc/odoo.conf"
    ]

    network_name = f"{os.path.basename(conf.get(profile, 'directory'))}_default"
    command.extend(bind_command)
    command.extend(["--network", network_name])
    command.append(image)
    docker_compose(["stop", f"{prefix}{args[2]}"])
    docker(command)
    docker_compose(["start", f"{prefix}{args[2]}"])


def init_module(args, flags, conf):
    """
    Initializes the specified modules in the specified database.
    """
    if len(args) != 5:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    profile = flags.get("profile", "default")
    prefix = conf.get(profile, "prefix")
    container_name = gen_container_name(args, flags, conf)
    res = json_loads(docker(["inspect", container_name], capture=True))[0]
    image = res['Config']['Image']
    binds = res['HostConfig']['Binds']
    test_enabled = flags.get("test", False)
    bind_command = []
    for bind in binds:
        bind_command.append(f"--volume={bind}")
    for var in res['Config']['Env']:
        key, value = var.split("=", 1)
        if key in UPDATE_VARIABLES:
            os.environ[key] = value
    test_enable_flag = "--test-enable" if test_enabled else ""
    command = ["run", "--rm", "--interactive", "--tty",
        "--env", "OPTIONS__ADDONS_PATH",
        "--env", "OPTIONS__DB_USER",
        "--env", "OPTIONS__DB_PASSWORD",
        "--env", "OPTIONS__DB_HOST",
        "--env", "OPTIONS__DB_PORT",
        "--env", "OPTIONS__DB_NAME",
        "--env", "OPTIONS__LOGFILE=",
        "--env", "NO_CHOWN",
        "--env", "OUID",
        "--env", "OGID",
        "--env", "PIP_INSTALL",
        "--env", "PIP_INSTALL_FILE",
        "--env", "ONESHOT=True",
        "--env", "PURGE_CACHE=True",
        "--env", "ODOO_STAGE=init",
        "--env", f"OARGS=--database={args[3]} --init={args[4]} --stop-after-init {test_enable_flag} --config /opt/odoo/etc/odoo.conf"
    ]

    network_name = f"{os.path.basename(conf.get(profile, 'directory'))}_default"
    command.extend(bind_command)
    command.extend(["--network", network_name])
    command.append(image)
    docker_compose(["stop", f"{prefix}{args[2]}"])
    docker(command)
    docker_compose(["start", f"{prefix}{args[2]}"])


def fscat(args, flags, conf):
    """
    Outputs a tarball of the specified database filestore.
    """
    if len(args) != 4:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    container_name = gen_container_name(args, flags, conf)
    res = json_loads(docker(["inspect", container_name], capture=True))[0]
    image = "busybox:latest"
    binds = res['HostConfig']['Binds']
    bind_command = []
    for bind in binds:
        bind_command.append(f"--volume={bind}")

    command = ["run", "--rm", "--entrypoint", "tar", 
        "--workdir", "/opt/odoo/data/filestore"
    ]

    command.extend(bind_command)
    command.extend([image, "cf", "-", args[3]])
    docker(command)


def cleanup(args, flags, conf):
    """
    Removes all dangling images
    """
    if len(args) != 2:
        raise InvalidArguments()
    docker(["image", "prune", "--all", "--force"])


def scaffold(args, flags, conf):
    """
    Generates an Odoo module skeleton.
    """
    if len(args) != 5:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    container_name = gen_container_name(args, flags, conf)
    res = json_loads(docker(["inspect", container_name], capture=True))[0]
    image = res['Config']['Image']
    command = ["run", "--rm", 
        "--entrypoint", "python",
        "--workdir", "/mnt",
        "--volume", f"{os.environ['REAL_PWD']}:/mnt",
        image, "/opt/odoo/server/odoo-bin", "scaffold", args[3], args[4]]
    docker(command)


def tail(args, flags, conf):
    """
    Views Odoo log live.
    """
    if len(args) != 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    lines = flags.get("lines", "10")
    container_name = gen_container_name(args, flags, conf)
    res = json_loads(docker(["inspect", container_name], capture=True))[0]
    logfile = [logfile_path for logfile_path in res['Config']['Env']
        if logfile_path.startswith("OPTIONS__LOGFILE")][0].split("=", 1)[1]
    command = ["exec", "--interactive", "--tty", container_name, "tail", "-f", logfile, "-n", lines]
    docker(command)


def dtail(args, flags, conf):
    """
    Views Odoo docker log live.
    """
    if len(args) != 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    lines = flags.get("lines", "10")
    container_name = gen_container_name(args, flags, conf)
    command = ["logs", "--follow", "--tail", lines, container_name]
    docker(command)


def psql(args, flags, conf):
    """
    Launches a psql shell for the specified odoo database.
    """
    if len(args) < 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    update_psql = flags.get("update", False)
    profile = flags.get("profile", "default")
    network_name = f"{os.path.basename(conf.get(profile, 'directory'))}_default"
    container_name = gen_container_name(args, flags, conf)
    psql_args = parse_args_after_delimiter()
    res = json_loads(docker(["inspect", container_name], capture=True))[0]
    for var in res['Config']['Env']:
        key, value = var.split("=", 1)
        if key in UPDATE_VARIABLES:
            os.environ[key] = value
    os.environ['PGHOST'] = os.environ.get('OPTIONS__DB_HOST', 'postgres')
    os.environ['PGPORT'] = os.environ.get('OPTIONS__DB_PORT', '5432')
    os.environ['PGUSER'] = os.environ.get('OPTIONS__DB_USER', 'odoo')
    os.environ['PGPASSWORD'] = os.environ.get('OPTIONS__DB_PASSWORD', 'odoo')
    command = ["run", "--rm", "--entrypoint", "psql", "--interactive", 
        "--workdir", "/mnt", "--volume", f"{os.environ['REAL_PWD']}:/mnt", "--env", "PGHOST",
        "--env", "PGPORT", "--env", "PGUSER", "--env", "PGPASSWORD", "--network", network_name]
    if update_psql:
        command.extend(["--pull", "always"])
    if stdin.isatty():
        command.append("--tty")
    command.append(PSQL_IMAGE)
    if psql_args:
        command.extend(psql_args)
    else:
        command.extend(args[3:])
    docker(command)


def pg_dump(args, flags, conf):
    """
    Dumps specified odoo database.
    """
    if len(args) < 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    update_psql = flags.get("update", False)
    profile = flags.get("profile", "default")
    network_name = f"{os.path.basename(conf.get(profile, 'directory'))}_default"
    container_name = gen_container_name(args, flags, conf)
    psql_args = parse_args_after_delimiter()
    res = json_loads(docker(["inspect", container_name], capture=True))[0]
    for var in res['Config']['Env']:
        key, value = var.split("=", 1)
        if key in UPDATE_VARIABLES:
            os.environ[key] = value

    os.environ['PGHOST'] = os.environ.get('OPTIONS__DB_HOST', 'postgres')
    os.environ['PGPORT'] = os.environ.get('OPTIONS__DB_PORT', '5432')
    os.environ['PGUSER'] = os.environ.get('OPTIONS__DB_USER', 'odoo')
    os.environ['PGPASSWORD'] = os.environ.get('OPTIONS__DB_PASSWORD', 'odoo')
    command = ["run", "--rm", "--entrypoint", "pg_dump", "--interactive", 
        "--workdir", "/mnt", "--volume", f"{os.environ['REAL_PWD']}:/mnt", "--env", "PGHOST",
        "--env", "PGPORT", "--env", "PGUSER", "--env", "PGPASSWORD", "--network", network_name]
    if update_psql:
        command.extend(["--pull", "always"])
    if stdin.isatty():
        command.append("--tty")
    command.append(PSQL_IMAGE)
    if psql_args:
        command.extend(psql_args)
    else:
        command.extend(args[3:])
    docker(command)


def pytest(args, flags, conf):
    """
    Runs pytest on the specified Odoo version.
    """
    if len(args) < 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    profile = flags.get("profile", "default")
    network_name = f"{os.path.basename(conf.get(profile, 'directory'))}_default"
    container_name = gen_container_name(args, flags, conf)
    pytest_args = parse_args_after_delimiter()
    res = json_loads(docker(["inspect", container_name], capture=True))[0]
    image = res['Config']['Image']
    binds = res['HostConfig']['Binds']
    bind_command = []
    for bind in binds:
        bind_command.append(f"--volume={bind}")
    for var in res['Config']['Env']:
        key, value = var.split("=", 1)
        if key in UPDATE_VARIABLES:
            os.environ[key] = value
    if "PIP_INSTALL" in os.environ:
        os.environ["PIP_INSTALL"] += ",pytest,pytest-odoo"
    else:
        os.environ["PIP_INSTALL"] = "pytest,pytest-odoo"
    command = ["run", "--rm", "--interactive", "--tty",
        "--env", "OPTIONS__ADDONS_PATH",
        "--env", "OPTIONS__DB_USER",
        "--env", "OPTIONS__DB_PASSWORD",
        "--env", "OPTIONS__DB_HOST",
        "--env", "OPTIONS__DB_PORT",
        "--env", "OPTIONS__DB_NAME",
        "--env", "OPTIONS__LOGFILE",
        "--env", "NO_CHOWN",
        "--env", "OUID",
        "--env", "OGID",
        "--env", "PIP_INSTALL",
        "--env", "PIP_INSTALL_FILE",
        "--env", "ONESHOT=True",
        "--env", "PURGE_CACHE=True",
        "--env", "ODOO_DRY_RUN=True",
        "--workdir", "/opt/odoo"
    ]

    command.extend(bind_command)
    command.extend(["--network", network_name])
    command.extend([image, "pytest"])
    if pytest_args:
        command.extend(pytest_args)
    else:
        command.extend(args[3:])
    docker(command)


def ehash(args, flags, conf):
    if len(args) < 3:
        raise InvalidArguments()
    check_odoo_exist(args[2], flags, conf)
    container_name = gen_container_name(args, flags, conf)
    res = json_loads(docker(["inspect", container_name], capture=True))[0]
    hash = res['Config']['Labels']['com.mplussoftware.enterprise.revision'] \
        if 'com.mplussoftware.enterprise.revision' in res['Config']['Labels'] else None
    print(hash)


def help(args, flags, conf, file=stdout):
    """
    Prints a list of available commands.
    """
    help_string = f"""Usage: {args[0]} <command> <args> <--optional-flags>

Manages Odoo containers in a docker stack

Commands:
"""
    functions = build_functions()
    for key, value in functions.items():
        args = ""
        for arg in value[1]:
            args += f" <{arg}>"
        desc = value[3]
        help_string += f"    {key + args: <40} {desc}\n"
    print(help_string, file=file)


def command_help(args, flags, conf, file=stdout):
    """
    Prints the help for the specified command.
    """
    functions = build_functions()
    needed_args = ""
    flags_help = ""
    if args[1] == "command-help" and len(args) == 3:
        args[1] = args[2]
    for arg in functions[args[1]][1]:
        needed_args += f" <{arg}>"
    for flags in functions[args[1]][2].items():
        flags_help += f"   --{flags[0]: <20} {flags[1]}\n"
    help_string = f"Usage: {args[0]} {args[1]}{needed_args} <--optional-flags>"
    help_string += f"\n\n{functions[args[1]][3]}"
    help_string += f"\n\nOptional flags:\n{flags_help}"
    print(help_string, file=file)


def build_functions():
    """
    Builds a dictionary of functions that can be called by the main function.
    """
    functions = {}
    # function, args, flags, description
    functions["create"] = create, ["version"], {}, "Creates (or recreates) an Odoo container from the newest image."
    functions["start"] = start, ["version"], {}, "Starts a stopped Odoo container."
    functions["stop"] = stop, ["version"], {}, "Stops a running Odoo container."
    functions["restart"] = restart, ["version"], {}, "Restarts a running Odoo container."
    functions["shell"] = shell, ["version"], {}, "Opens a shell in the container as 'odoo' user."
    functions["top"] = top, ["version"], {},"Displays the top processes running in the container."
    functions["update"] = update, ["version"], {}, "Pulls the latest Odoo image."
    functions["update-module"] = update_module, ["version", "db", "addons"], {"test": "Run a test when updating module"}, "Updates the specified modules in the specified database."
    functions["init-module"] = init_module, ["version", "db", "addons"], {"test": "Run a test when initializing module"}, "Initializes the specified modules in the specified database."
    functions["fscat"] = fscat, ["version", "db"], {}, "Outputs a tarball of the specified database filestore."
    functions["scaffold"] = scaffold, ["version", "module", "directory"], {}, "Generates an Odoo module skeleton."
    functions["tail"] = tail, ["version"], {"lines=NUM": "Get last NUM lines (default: 10)"}, "Views Odoo log live."
    functions["dtail"] = dtail, ["version"], {"lines=NUM": "Get last NUM lines (default: 10)"}, "Views Odoo docker log live."
    functions["attach"] = attach, ["version"], {"no-prompt": "Skip the screen prompt"}, "Attaches to an Odoo process in the specified container."
    functions["cleanup"] = cleanup, [], {}, "Removes all dangling images."
    functions["ps"] = ps, [], {}, "Lists all containers."
    functions["psql"] = psql, ["version"], {"update": "Update PostgreSQL client"}, "Launches a psql shell for the specified odoo database."
    functions["pg_dump"] = pg_dump, ["version"], {"update": "Update PostgreSQL client"}, "Dumps specified odoo database."
    functions["pytest"] = pytest, ["version"], {}, "Runs pytest."
    functions["ehash"] = ehash, ["version"], {}, "Get matching Odoo Enterprise commit hash."
    functions["help"] = help, [], {}, "Shows this help."
    functions["command-help"] = command_help, ["command"], {}, "Shows help for the specified command."

    # Add global flags
    for command in functions:
        if SYSTEM == "Linux":
            functions[command][2]["config"] = "Specify a config file to use. Def: /etc/odooctl.conf"
        else:
            functions[command][2]["config"] = "Specify a config file to use. Def: ~/.odooctl.conf"
        functions[command][2]["profile"] = "Specify a profile to use. Def: default"
        functions[command][2]["remote=STR"] = "Connect to a remote server. Alt: ODOOCTL_REMOTE"
        functions[command][2]["sudo"] = "Execute command in a remote server with sudo. Alt: ODOOCTL_SUDO"
    return functions


def remote_ssh(args, flags):
    """
    Connect to a server with odooctl installed.
    """
    conn_string = os.environ["ODOOCTL_REMOTE"] if "remote" not in flags else flags["remote"]
    try:
        user = conn_string.split("@")[0] if "@" in conn_string else False
        host = conn_string.split("@")[1].split(":")[0] if "@" in conn_string else conn_string
        port = conn_string.split(":")[1] if ":" in conn_string else False
    except IndexError:
        write_err("Invalid remote connection string.")
    ssh_command = "ssh"
    sudo = "sudo" if flags.get("sudo") or "ODOOCTL_SUDO" in os.environ else ""
    if user:
        ssh_command += f" -l {user}"
    if port:
        ssh_command += f" -p {port}"
    ssh_command += f" -o LogLevel=QUIET -t {host} -- {sudo} odooctl "
    ssh_command += " ".join(args[1:]) + " "
    flags_arr = []
    unpassed_flags = ["remote", "sudo"]
    for flag in flags:
        if flag not in unpassed_flags:
            if flags[flag] == True:
                flags_arr.append(f"--{flag}")
            else:
                flags_arr.append(f"--{flag}={flags[flag]}")
    ssh_command += " ".join(flags_arr)
    return os.system(ssh_command)


def main():
    # Check if the running platform is Linux, if Linux, we would want to set the path 
    # only to /usr/bin or /usr/local/bin for security reasons. we'll asume other system
    # is only being used for development.
    if SYSTEM == "Linux":
        os.environ["PATH"] = "/usr/bin:/usr/local/bin"
    
    args, flags = parse_args()
    if "remote" in flags or "ODOOCTL_REMOTE" in os.environ:
        exit(remote_ssh(args, flags))

    if SYSTEM == "Linux":
        conf = parse_config(os.path.expanduser(flags.get("config", "/etc/odooctl.conf" if os.getuid() == 0 else "~/.odooctl.conf")))
    else:
        # We'll assume that other than "Linux", Docker daemon is running remotely and
        # thus there's no need to put the config in privileged directories.
        conf = parse_config(os.patj.expanduser(flags.get("config", "~/.odooctl.conf")))
    profile = flags.get("profile", "default")
    os.environ["REAL_PWD"] = os.getcwd()

    try:
        os.chdir(os.path.expanduser(conf.get(profile, "directory")))
    except NoSectionError:
        write_err(f"No profile '{profile}' found in config file.")
        help(args, flags, conf, stderr)
        exit(1)
    except NoOptionError:
        write_err(f"No directory specified in profile '{profile}'.")
        help(args, flags, conf, stderr)
        exit(1)
    except FileNotFoundError:
        write_err(f"Directory '{conf.get(profile, 'directory')}' not found.")
        help(args, flags, conf, stderr)
        exit(1)


    functions = build_functions()
    try:
        functions[args[1]][0](args, flags, conf)
    except KeyError:
        help(args, flags, conf, stderr)
        exit(2)
    except IndexError:
        help(args, flags, conf, stderr)
        exit(2)
    except InvalidArguments:
        command_help(args, flags, conf, stderr)
        exit(2)
    except OdooDoesNotExist:
        write_err(f"Odoo {args[2]} does not exist in the stack.")
        exit(3)
    except DockerError as e:
        write_err(f"Docker exited with code: {e}")
        exit(4)
    except KeyboardInterrupt:
        print("\nExiting...")
        exit(0)
    except YAMLError:
        write_err("Invalid docker-compose.yml file.")
        exit(6)


if __name__ == "__main__":
    main()
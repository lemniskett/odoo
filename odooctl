#!/usr/bin/env python3

import yaml
import hcl2
import subprocess
import json
# import odoorpc
from os import system, path, mkdir, environ, getcwd, getuid, system, chdir
from platform import uname
from sys import argv, stderr, stdin
from hashlib import sha256
from pathlib import Path
from copy import deepcopy
from collections import namedtuple


DOCKER_COMPOSE_VERSION = "2"
TRAEFIK_IMAGE = "docker.io/library/traefik"
TRAEFIK_TAG = "2.8"
ODOO_IMAGE = "registry.gitlab.com/mplus-software/odoo"
PSQL_IMAGE = "quay.io/lemniskett/psql"

ODOOCTL_DIR = environ.get("ODOOCTL_DIR", getcwd())
ODOOCTL_DOCKER_DIR = environ.get("ODOOCTL_DOCKER_DIR", f"{ODOOCTL_DIR}/.odooctl")

XMLRPC_PORT = 8069
LONGPOLLING_PORT = 8072

commands = {}


class InvalidArguments(Exception):
    pass


class InvalidFlags(Exception):
    pass


class OdooDoesNotExist(Exception):
    pass


class DockerError(Exception):
    pass


def command(**kwargs):
    def wrapper(func):
        default_flags = {
            "help": "Shows help for this command",
        }
        commands[func.__name__.replace("_", "-")] = {
            "func": func,
            "description": kwargs.get("description", ""),
            "args": kwargs.get("args", []),
            "flags": dict(**kwargs.get("flags", {}), **default_flags),
        }
        
        return func
    return wrapper


def help_hook(args, flags, user_command):
    if not flags.get("help", False):
        return

    needed_args = ""
    flags_help = ""
    for args in commands[user_command]["args"]:
        needed_args += f" <{args}>"
    for flag_key, flag_help in commands[user_command]["flags"].items():
        flags_help += f"   --{flag_key: <16} {flag_help}\n"
    help_string = f"Usage: {argv[0]} {user_command}{needed_args} <--optional-flags>"
    help_string += f"\n\n{commands[user_command]['description']}"
    help_string += f"\n\nOptional flags:\n{flags_help}"
    print(help_string)
    exit(0)


def parse_args(argv):
    # Using argsparser is too complicated for positional arguments, so we'll have this instead.
    """
    Parses the arguments passed to the script.
    """
    args = []
    flags = {}

    for arg in argv:
        if arg == "--":
            break
        elif arg.startswith("--"):
            if '=' not in arg:
                flags[arg[2:]] = True
                continue
            key, value = arg[2:].split("=")
            flags[key] = value
        else:
            args.append(arg)

    return args[1:], flags


def parse_config(path):
    """
    Parses the config file.
    """
    try:
        with open(path) as f:
            return hcl2.load(f)
    except FileNotFoundError:
        write_err("Odoofile not found. create one or use an existing one using ODOOCTL_DIR environment variable.")
        exit(10)


def write_err(string):
    """
    Writes a string to stderr.
    """
    print(string, file=stderr)


def create_dir(filepath):
    try:
        if not path.isdir(filepath):
            Path(filepath).mkdir(parents=True, exist_ok=True)
            
    except FileExistsError:
        write_err(f"{filepath} is not a directory.")
        exit(10)


def create_context(args, flags, user_command):
    ctx = {'user_command': user_command}
    if len(args) - 1 != len(commands[user_command]["args"]):
        raise InvalidArguments()

    for i in range(len(commands[user_command]["args"])):
        ctx[commands[user_command]["args"][i]] = args[i+1]

    for key in commands[user_command]["flags"]:
        if key in flags:
            ctx[key] = flags[key]
        else:
            ctx[key] = False

    for key in flags:
        if key not in commands[user_command]["flags"]:
            raise InvalidFlags(key)

    ctx = {key.replace("-", "_"): value for key, value in ctx.items()}
    ctx = namedtuple("Context", ctx.keys())(*ctx.values())
    return ctx


def docker(args, **kwargs):
    print(args)
    array_args = []
    for i in range(len(args)):
        array_args.append(f"'{args[i]}'")
    cmd = f"docker {' '.join(array_args)}"

    if kwargs.get("capture", False):
        res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        if res.returncode != 0:
            raise DockerError(res.returncode)
        return res.stdout.decode("utf-8"), res.returncode
    exit_code = system(cmd)
    if exit_code != 0:
        raise DockerError(exit_code)


def download_file(url, file_name, **kwargs):
    cmd = f"curl -X POST -L {url} -o {file_name} -m 3600"
    for key, value in kwargs.items():
        cmd += f" --data-urlencode {key}={value}"
    exit_code = system(cmd)
    return exit_code


def create_network(name):
    """
    Creates the network.
    """
    # output, code = 
    # if code == 0:
    #     return
    try:
        docker(["network", "inspect", name], capture=True)
    except DockerError:
        docker(["network", "create", name], capture=True)


def parse_odoo_conf(conf):
    odoo_conf = {}
    for odoo_server in conf:
        odoo_conf.update(odoo_server)
    return odoo_conf


def generate_conf(traefik_conf, odoo_conf):
    """
    Generates the configuration files.
    """
    network_name = getcwd()[1:].replace("/", "-")
    docker_socket = environ.get('DOCKER_HOST', environ.get('XDG_RUNTIME_DIR', '/run/user/' + str(getuid()) + '/docker.sock')).replace("unix://", "")
    traefik_compose = {
        'version': DOCKER_COMPOSE_VERSION,
        'services': {
            'traefik': {
                'container_name': f'{network_name}-traefik',
                'image': f'{TRAEFIK_IMAGE}:{TRAEFIK_TAG}',
                'ports': [
                    f'{traefik_conf.get("port", 8080)}:8080',
                    '80:80',
                    '443:443'
                ],
                'volumes': [
                    f"{docker_socket}:/var/run/docker.sock",
                    './config:/etc/traefik:ro',
                    f'{ODOOCTL_DIR}/logs/traefik:/logs'
                ],
                'environment': {},
                'restart': 'unless-stopped',
                'labels': {
                    'traefik.enable': 'false',
                },
            }
        },
        'networks': {
            'default': {
                'name': network_name,
                'external': True
            }
        }
    }

    odoo_compose_template = {
        'version': DOCKER_COMPOSE_VERSION,
        'services': {},
        'networks': {
            'default': {
                'name': network_name,
                'external': True
            }
        }
    }

    traefik = {
        'providers': {
            'docker': {}
        },
        'entryPoints': {
            'web': {
                'address': ':80'
            }
        },
        'accessLog': {
            'filePath': '/logs/access.log'
        },
        'api': {
            'dashboard': True,
            'insecure': True
        }
    }

    entrypoint = 'web'
    if traefik_conf.get('ssl', {}).get('enable', False):
        domains = []
        entrypoint = 'websecure'
        ssl_provider = traefik_conf['ssl'].get('provider', 'default')

        for version in odoo_conf:
            domains.append({
                'main': odoo_conf[version]['hostname'],
                'sans': odoo_conf[version].get("sans", [])
            })
        
        traefik['entryPoints']['web']['http'] = {
            'redirections': {
                'entryPoint': {
                    'to': 'websecure',
                    'scheme': 'https',
                    'permanent': True
                }
            }
        }
        traefik['entryPoints']['websecure'] = {
            'address': ':443',
            'http': {
                'tls': {
                    'certResolver': 'default',
                    'domains': domains
                }
            }
        }

        if ssl_provider == "http":
            traefik['certificatesResolvers'] = {
                'default': {
                    'acme': {
                        'email': traefik_conf['ssl']['email'],
                        'storage': '/etc/traefik/acme.json',
                        'httpChallenge': {
                            'entryPoint': 'web'
                        }
                    }
                }
            }
        else:
            traefik['certificatesResolvers'] = {
                'default': {
                    'acme': {
                        'email': traefik_conf['ssl']['email'],
                        'storage': '/etc/traefik/acme.json',
                        'dnsChallenge': {
                            'provider': ssl_provider,
                            'resolvers': [
                                '1.1.1.1:53',
                                '8.8.8.8:53'
                            ]
                        }
                    }
                }
            }
            for secret in traefik_conf['ssl']['secrets']:
                traefik_compose['services']['traefik']['environment'][secret.upper()] = traefik_conf['ssl']['secrets'][secret]


    for odoo_id in odoo_conf:
        odoo_compose = deepcopy(odoo_compose_template)
        create_dir(f"{ODOOCTL_DOCKER_DIR}/odoo-{odoo_id}/config")
        odoo_compose['services'][f'odoo-{odoo_id}'] = {
            'container_name': f'{network_name}-odoo-{odoo_id}',
            'image': f'{ODOO_IMAGE}:{odoo_conf[odoo_id]["version"]}',
            'volumes': [
                f'{ODOOCTL_DIR}/.pip-cache:/opt/odoo/pip-cache',
                f'{ODOOCTL_DIR}/.apt-cache:/var/cache/apt/archives',
                f'{ODOOCTL_DIR}/odoo-{odoo_id}/data:/opt/odoo/data',
                f'{ODOOCTL_DIR}/odoo-{odoo_id}/extra-addons:/opt/odoo/extra-addons',
                f'{ODOOCTL_DIR}/logs/odoo-{odoo_id}:/opt/odoo/logs',
                *odoo_custom_mount(odoo_conf[odoo_id].get('mounts', []), odoo_id)
            ],
            'restart': 'unless-stopped',
            'ports': [
                f'{odoo_conf[odoo_id]["xmlrpc_port"]}:8069',
                f'{odoo_conf[odoo_id]["longpolling_port"]}:8069'
            ],
            'labels': generate_traefik_labels(odoo_id, entrypoint, odoo_conf[odoo_id]),
            'environment': generate_odoo_conf(odoo_conf[odoo_id]["config"], odoo_id),
        }

        with open(f"{ODOOCTL_DOCKER_DIR}/odoo-{odoo_id}/docker-compose.yml", "w") as f:
            yaml.dump(odoo_compose, f)

    if traefik_conf.get('enable', True):
        create_dir(f"{ODOOCTL_DOCKER_DIR}/traefik/config")
        with open(f"{ODOOCTL_DOCKER_DIR}/traefik/config/traefik.yml", "w") as f:
            yaml.dump(traefik, f)
        traefik_hash = sha256(json.dumps(traefik, sort_keys=True).encode('utf-8')).hexdigest()
        traefik_compose['services']['traefik']['labels']['config.hash'] = traefik_hash
        with open(f"{ODOOCTL_DOCKER_DIR}/traefik/docker-compose.yml", "w") as f:
            yaml.dump(traefik_compose, f)


def odoo_custom_mount(mounts, odoo_id):
    custom_mounts = []
    for mount in mounts:
        custom_mounts.append(f"{mount}:{mounts[mount]}".replace('${data}', f'{ODOOCTL_DIR}/odoo-{odoo_id}'))
    return custom_mounts


def generate_traefik_labels(odoo_id, entrypoint, conf):
    hostname = conf['hostname']
    sans = conf.get("sans", [])
    odoo_conf_hash = sha256(json.dumps(conf['config'], sort_keys=True).encode('utf-8')).hexdigest()
    hostname_matcher = "Host"
    hostname_label_name = f'{hostname.replace(".", "-")}-odoo-{odoo_id}'
    if "*" in hostname:
        matcher = "HostRegexp"
        hostname = hostname.replace("*", "{subdomain:[a-zA-Z0-9]+}")
    labels = {
        'config.hash': odoo_conf_hash,
        'traefik.enable': 'true',
        f'traefik.http.routers.{hostname_label_name}.rule': f'{hostname_matcher}(`{hostname}`)',
        f'traefik.http.routers.{hostname_label_name}.entrypoints': entrypoint,
        f'traefik.http.routers.{hostname_label_name}.service': hostname_label_name,
        f'traefik.http.services.{hostname_label_name}.loadbalancer.server.port': XMLRPC_PORT,
        f'traefik.http.routers.{hostname_label_name}-rt.rule': f'{hostname_matcher}(`{hostname}`) && PathPrefix(`/longpolling`)',
        f'traefik.http.routers.{hostname_label_name}-rt.entrypoints': entrypoint,
        f'traefik.http.routers.{hostname_label_name}-rt.service': f'{hostname_label_name}-rt',
        f'traefik.http.services.{hostname_label_name}-rt.loadbalancer.server.port': LONGPOLLING_PORT
    }
    for san in sans:
        san_matcher = "Host"
        san_label_name = f'{san.replace(".", "-")}-odoo-{odoo_id}'
        if "*" in san:
            san_matcher = "HostRegexp"
            san = san.replace("*", "{subdomain:[a-z0-9]+}")
        san_labels = {
            f'traefik.http.routers.{san_label_name}.rule': f'{san_matcher}(`{san}`)',
            f'traefik.http.routers.{san_label_name}.entrypoints': entrypoint,
            f'traefik.http.routers.{san_label_name}.service': san_label_name,
            f'traefik.http.services.{san_label_name}.loadbalancer.server.port': XMLRPC_PORT,
            f'traefik.http.routers.{san_label_name}-rt.rule': f'{san_matcher}(`{san}`) && PathPrefix(`/longpolling`)',
            f'traefik.http.routers.{san_label_name}-rt.entrypoints': entrypoint,
            f'traefik.http.routers.{san_label_name}-rt.service': f'{san_label_name}-rt',
            f'traefik.http.services.{san_label_name}-rt.loadbalancer.server.port': LONGPOLLING_PORT
        }
        labels.update(san_labels)

    return labels


def get_odoo_env(odoo_id, network_name):
    res = json.loads(docker(["inspect", "--format", '{{json .Config.Env}}', f'{network_name}-odoo-{odoo_id}'], capture=True)[0])
    env = {kv.split('=')[0]: kv.split('=')[1] for kv in res}
    return env


def generate_odoo_conf(conf, odoo_id):
    odoo_env = {
        'ODOOCONF__options__proxy_mode': 'True',
    }
    for section, keys in conf.items():
        for key, value in keys.items():
            odoo_env[f"ODOOCONF__{section}__{key}"] = value

    return odoo_env


def parse_args_after_delimiter():
    """
    Parses the arguments after the delimiter string "--"
    """
    args = []
    passed_delimiter = False
    for arg in argv:
        if passed_delimiter:
            args.append(arg)
        if arg == "--":
            passed_delimiter = True
    return args


@command(description="Shows this help message.")
def help(ctx, conf):
    """
    Prints a list of available commands.
    """
    help_string = f"""Usage: {argv[0]} <command> <args> <--optional-flags>

Manages Odoo containers in a docker stack

Commands:
"""
    for key, value in commands.items():
        args = ""
        for arg in value["args"]:
            args += f" <{arg}>"
        desc = value["description"]
        help_string += f"    {key + args: <40} {desc}\n"
    print(help_string, file=stderr)


@command(description="Reconfigures the stack")
def reconfigure(ctx, conf):
    """
    Reconfigures the stack.
    """
    create_dir(ODOOCTL_DOCKER_DIR)
    create_network(getcwd()[1:].replace("/", "-"))

    traefik_conf = conf.get('traefik', [{'enable': False}])[0]
    odoo_conf = parse_odoo_conf(conf.get('odoo', {}))
    generate_conf(traefik_conf, odoo_conf)

    chdir(f'{ODOOCTL_DOCKER_DIR}/traefik')
    if traefik_conf.get('enable', True):
        docker(["compose", "up", "-d"])
    else:
        docker(["compose", "down"])

    for odoo_id in odoo_conf:
        chdir(f'{ODOOCTL_DOCKER_DIR}/odoo-{odoo_id}')    
        docker(["compose", "up", "-d"])


@command(description="Starts an Odoo instance", args=["odoo-id"])
def start(ctx, conf):
    """
    Starts an Odoo instance.
    """
    chdir(f'{ODOOCTL_DOCKER_DIR}/odoo-{ctx.odoo_id}')
    docker(["compose", "up", "-d"])    


@command(description="Stops an Odoo instance", args=["odoo-id"])
def stop(ctx, conf):
    """
    Stops an Odoo instance.
    """
    chdir(f'{ODOOCTL_DOCKER_DIR}/odoo-{ctx.odoo_id}')
    docker(["compose", "down"])


@command(description="Restarts an Odoo instance", args=["odoo-id"])
def restart(ctx, conf):
    """
    Restarts an Odoo instance.
    """
    chdir(f'{ODOOCTL_DOCKER_DIR}/odoo-{ctx.odoo_id}')
    docker(["compose", "restart"])


@command(description="Updates an Odoo instance", args=["odoo-id"])
def update(ctx, conf):
    """
    Updates an Odoo instance.
    """
    chdir(f'{ODOOCTL_DOCKER_DIR}/odoo-{ctx.odoo_id}')
    docker(["compose", "pull"])
    docker(["compose", "up", "-d"])


@command(description="Initializes odoo modules", args=["odoo-id", "db", "modules"])
def init_module(ctx, conf):
    """
    Initializes odoo modules.
    """
    network_name = getcwd()[1:].replace("/", "-")
    odoo_conf = parse_odoo_conf(conf.get('odoo', {}))
    version = odoo_conf[ctx.odoo_id]['version']
    env = get_odoo_env(ctx.odoo_id, network_name)
    bind_mounts = [
        f'{ODOOCTL_DIR}/.pip-cache:/opt/odoo/pip-cache',
        f'{ODOOCTL_DIR}/odoo-{ctx.odoo_id}/data:/opt/odoo/data',
        f'{ODOOCTL_DIR}/odoo-{ctx.odoo_id}/extra-addons:/opt/odoo/extra-addons',
        f'{ODOOCTL_DIR}/logs/odoo-{ctx.odoo_id}:/opt/odoo/logs',
        *odoo_custom_mount(odoo_conf[ctx.odoo_id].get('mounts', []), ctx.odoo_id)]
    bind_mount_commands = [f"--volume={mount}" for mount in bind_mounts]

    for e in env:
        environ[e] = env[e]
    cmd = ["run", "--rm", "--interactive", "--tty",
        "--network", network_name,
        *bind_mount_commands,
        "--env", "ODOOCONF__options__addons_path",
        "--env", "ODOOCONF__options__db_user",
        "--env", "ODOOCONF__options__db_password",
        "--env", "ODOOCONF__options__db_host",
        "--env", "ODOOCONF__options__db_port",
        "--env", "ODOOCONF__options__db_name",
        "--env", "ODOOCONF__options__logfile",
        "--env", "PIP_INSTALL",
        "--env", "PIP_INSTALL_FILE",
        "--env", "ONESHOT=True",
        "--env", "PURGE_CACHE=True",
        "--env", "ODOO_STAGE=init",
        "--env", "ODOO_DISABLE_TTY=True",
        "--env", f"OARGS=--database={ctx.db} --init={ctx.modules} --stop-after-init --config=/opt/odoo/etc/odoo.conf",
        f"{ODOO_IMAGE}:{version}"
    ]
    docker(cmd)


@command(description="Updates odoo modules", args=["odoo-id", "db", "modules"])
def update_module(ctx, conf):
    """
    Initializes odoo modules.
    """
    network_name = getcwd()[1:].replace("/", "-")
    odoo_conf = parse_odoo_conf(conf.get('odoo', {}))
    version = odoo_conf[ctx.odoo_id]['version']
    env = get_odoo_env(ctx.odoo_id, network_name)
    bind_mounts = [
        f'{ODOOCTL_DIR}/.pip-cache:/opt/odoo/pip-cache',
        f'{ODOOCTL_DIR}/odoo-{ctx.odoo_id}/data:/opt/odoo/data',
        f'{ODOOCTL_DIR}/odoo-{ctx.odoo_id}/extra-addons:/opt/odoo/extra-addons',
        f'{ODOOCTL_DIR}/logs/odoo-{ctx.odoo_id}:/opt/odoo/logs',
        *odoo_custom_mount(odoo_conf[ctx.odoo_id].get('mounts', []), ctx.odoo_id)]
    bind_mount_commands = [f"--volume={mount}" for mount in bind_mounts]

    for e in env:
        environ[e] = env[e]
    cmd = ["run", "--rm", "--interactive", "--tty",
        "--network", network_name,
        *bind_mount_commands,
        "--env", "ODOOCONF__options__addons_path",
        "--env", "ODOOCONF__options__db_user",
        "--env", "ODOOCONF__options__db_password",
        "--env", "ODOOCONF__options__db_host",
        "--env", "ODOOCONF__options__db_port",
        "--env", "ODOOCONF__options__db_name",
        "--env", "ODOOCONF__options__logfile",
        "--env", "PIP_INSTALL",
        "--env", "PIP_INSTALL_FILE",
        "--env", "ONESHOT=True",
        "--env", "PURGE_CACHE=True",
        "--env", "ODOO_STAGE=init",
        "--env", "ODOO_DISABLE_TTY=True",
        "--env", f"OARGS=--database={ctx.db} --update={ctx.modules} --stop-after-init --config=/opt/odoo/etc/odoo.conf",
        f"{ODOO_IMAGE}:{version}"
    ]
    docker(cmd)


@command(description="Opens a shell in an Odoo instance", args=["odoo-id"])
def shell(ctx, conf):
    """
    Opens a shell in an Odoo instance.
    """
    chdir(f'{ODOOCTL_DOCKER_DIR}/odoo-{ctx.odoo_id}')
    docker(["compose", "exec", f"odoo-{ctx.odoo_id}", "bash"])


@command(description="Displays processes running in an Odoo instance", args=["odoo-id"])
def top(ctx, conf):
    """
    Displays processes running in an Odoo instance.
    """
    chdir(f'{ODOOCTL_DOCKER_DIR}/odoo-{ctx.odoo_id}')
    docker(["compose", "top", f"odoo-{ctx.odoo_id}"])


@command(description="Views the logs of an Odoo instance", args=["odoo-id"], flags={"lines": "Get last NUM lines (default: 10)"})
def tail(ctx, conf):
    """
    Views the logs of an Odoo instance.
    """
    chdir(f'{ODOOCTL_DOCKER_DIR}/odoo-{ctx.odoo_id}')
    lines = "10" if not ctx.lines else ctx.lines
    docker(["compose", "logs", "--no-log-prefix", "--follow", "--tail", lines, f"odoo-{ctx.odoo_id}"])


# @command(description="List all databases", args=["odoo-id"])
# def list_db(ctx, conf):
#     port = odoo_conf[ctx.odoo_id]['xmlrpc_port']
#     odoo = odoorpc.ODOO('localhost', port=port)
#     print(odoo.db.list())


@command(description="Attaches to an Odoo process", args=["odoo-id"], flags={'no-prompt': 'Skip the screen prompt'})
def attach(ctx, conf):
    """
    Attaches to an Odoo instance.
    """
    network = getcwd()[1:].replace("/", "-")
    if not ctx.no_prompt:
        print("This is an interactive screen session.\nUse Ctrl-A + D to detach from the container.")
        input("Press enter to continue...")
    
    docker(["exec", "-it", f"{network}-odoo-{ctx.odoo_id}", "screen", "-xS", "odoo"])


@command(description="List all status of Odoo instances")
def status(ctx, conf):
    """
    Lists all status of Odoo instances.
    """
    odoo_conf = parse_odoo_conf(conf.get('odoo', {}))
    chdir(f'{ODOOCTL_DOCKER_DIR}/traefik')
    docker(["compose", "ps", "-a"])
    print()
    for odoo_id in odoo_conf:
        chdir(f'{ODOOCTL_DOCKER_DIR}/odoo-{odoo_id}')
        docker(["compose", "ps", "-a"])
        print()


@command(description="Deletes the stack")
def destroy(ctx, conf):
    """
    Deletes the stack.
    """
    chdir(f'{ODOOCTL_DOCKER_DIR}/traefik')
    docker(["compose", "down"])
    for odoo_id in parse_odoo_conf(conf.get('odoo', {})):
        chdir(f'{ODOOCTL_DOCKER_DIR}/odoo-{odoo_id}')
        docker(["compose", "down"])
    chdir(ODOOCTL_DIR)
    print("Removing network ", end="")
    docker(["network", "rm", network_name(ctx, conf)])


@command(description="Backups the database", args=["odoo-id", "db_name"])
def backup(ctx, conf):
    """
    Backups the database.
    """
    network_name = getcwd()[1:].replace("/", "-")
    odoo_conf = parse_odoo_conf(conf.get('odoo', {}))
    port = odoo_conf[ctx.odoo_id]['xmlrpc_port']
    url = f"http://localhost:{port}/web/database/backup"
    odoo_env = get_odoo_env(ctx.odoo_id, network_name)
    file_name = f"{ctx.db_name}.zip"
    
    download_file(url, file_name, master_pwd=odoo_env["ODOOCONF__options__admin_passwd"], name=ctx.db_name, backup_format="zip")


@command(description="Get matching Odoo Enterprise commit hash.", args=["odoo-id"])
def ehash(ctx, conf):
    """
    Get matching Odoo Enterprise commit hash.
    """
    # Get label com.mplussoftware.enterprise.revision from the container
    network = getcwd()[1:].replace("/", "-")
    docker(["inspect", "--format", "{{index .Config.Labels \"com.mplussoftware.enterprise.revision\"}}", f"{network}-odoo-{ctx.odoo_id}"])


@command(description="Get network name")
def network_name(ctx, conf):
    """
    Get network name.
    """
    network_name = getcwd()[1:].replace("/", "-")
    print(network_name)
    return network_name


@command(description="Launch psql client", args=["odoo-id"], flags={"pspg": "Use pspg pager", "update": "Updates the psql"})
def psql(ctx, conf):
    """
    Launch psql client.
    """
    psql_args = parse_args_after_delimiter()
    network = getcwd()[1:].replace("/", "-")
    odoo_env = get_odoo_env(ctx.odoo_id, network)
    pager = "pspg" if ctx.pspg else "less"
    update_psql = ctx.update

    environ['PGHOST'] = odoo_env.get("ODOOCONF__options__db_host", "postgres")
    environ['PGPORT'] = odoo_env.get("ODOOCONF__options__db_port", "5432")
    environ['PGUSER'] = odoo_env.get("ODOOCONF__options__db_user", "odoo")
    environ['PGPASSWORD'] = odoo_env.get("ODOOCONF__options__db_passwd", "odoo")
    cmd = ["run", "--rm", "--entrypoint", "psql", "--interactive", 
        "--workdir", "/mnt", "--volume", f"{environ['PWD']}:/mnt", "--env", "PGHOST",
        "--env", "PGPORT", "--env", "PGUSER", "--env", "PGPASSWORD", "--env", f"PAGER={pager}",
        "--network", network]
    if update_psql:
        cmd.extend(["--pull", "always"])
    if stdin.isatty():
        cmd.append("--tty")
    cmd.extend([PSQL_IMAGE, *psql_args])
    docker(cmd)


def main():
    if not (uname().system == "Linux" and system("systemctl --version >/dev/null 2>&1") == 0):
        write_err("This script only supports GNU/Linux OS with systemd")

    args, flags = parse_args(argv)
    conf = parse_config(flags.get("config", "./Odoofile"))
    try:
        user_command = args[0]
    except IndexError:
        write_err(f"See `{argv[0]} help` for more information.")
        exit(1)

    help_hook(args, flags, user_command)

    try: 
        ctx = create_context(args, flags, user_command)
    except InvalidFlags as e:
        write_err(f"Invalid flag: --{e}")
        write_err(f"See `{argv[0]} {args[0]} --help` for more information.")
        exit(1)
    except InvalidArguments:
        write_err(f"Invalid number of arguments.")
        write_err(f"See `{argv[0]} {args[0]} --help` for more information.")
        exit(1)
    except KeyError:
        write_err(f"Invalid command: {user_command}.")
        write_err(f"See `{argv[0]} help` for more information.")
        exit(1)

    try:
        commands[args[0]]["func"](ctx, conf)
    except DockerError as e:
        write_err(f"Docker exited with code: {e}")
        exit(4)
    except KeyError as e:
        write_err(f"Configuration error: {e} is missing.")
        exit(2)


if __name__ == "__main__":
    main()
